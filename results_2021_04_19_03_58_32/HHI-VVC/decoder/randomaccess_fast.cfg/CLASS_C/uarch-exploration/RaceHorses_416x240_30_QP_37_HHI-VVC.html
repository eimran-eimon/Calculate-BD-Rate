<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<html><style>
        .metric-name {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        }

        .metric-value {
        margin-left: 1em;
        color: #336;
        }

        .metric-value-with-issue {
        margin-left: 1em;
        color: #C33;
        }

        li {
        list-style-type: none;
        }

        ul {
        margin-left: 1.5em;
        padding-left: 0em;
        }

        body {
        margin: 0;
        paddind: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: #336;
        }

        pre {
        white-space:pre-wrap;
        max-width: 40em;
        color: #633;
        }

        .issue {
        border-left: 3px solid #C33;
        padding: 0.3em 0.3em 0.3em 1em;
        }

        table {
        margin: 0 1.5em;
        }

        th, td {
        text-align: left;
        }

        td {
        color: #333;
        }

        th {
        border-bottom: 2px solid #336;
        font-weight: 600;
        }

        .table-value {
        margin-right: 1.5em;
        }

        .brand {
        background-color: #0071c5;
        padding: 0.5em 1.5em;
        width: 100%;
        color: white;
        font-weight: 600;
        }

        .recommendation-placeholder {
        background-color: #eaecee;
        padding: 1em;
        }

        .recommendation-placeholder p {
        font-weight: 600;
        margin: 0;
        }

        .recommendation {
        border-left: 3px solid #bbb;
        padding: 0.3em 0.3em 0.3em 1em;
        margin: 0 0 0 1.5em;
        }

        .recommendation-metric {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        margin: 0 0 0 1.5em;
        }

      </style><body><div class="brand">Intel<sup>&reg;</sup> oneAPI VTune<sup>&trade;</sup> Profiler 2021.1.1 Gold</div><ul><li><span class="metric-name">Elapsed Time:
        </span><span class="metric-value-with-issue">0.038s<div class="issues"><pre class="issue">Application execution time is too short. Metrics data may be unreliable. Consider reducing the sampling interval or increasing your application execution time.</pre></div></span><ul><li><span class="metric-name">Clockticks:
        </span><span class="metric-value">118,440,000</span></li></ul><ul><li><span class="metric-name">Instructions Retired:
        </span><span class="metric-value">96,660,000</span></li></ul><ul><li><span class="metric-name">CPI Rate:
        </span><span class="metric-value-with-issue">1.225<div class="issues"><pre class="issue">The CPI may be too high. This could be caused by issues such as memory stalls, instruction starvation, branch misprediction or long latency instructions. Explore the other hardware-related metrics to identify what is causing high CPI.</pre></div></span></li></ul><ul><li><span class="metric-name">MUX Reliability:
        </span><span class="metric-value">0.997</span></li></ul><ul><li><span class="metric-name">Retiring:
        </span><span class="metric-value">30.8% of Pipeline Slots</span><ul><li><span class="metric-name">Light Operations:
        </span><span class="metric-value">26.2% of Pipeline Slots</span><ul><li><span class="metric-name">FP Arithmetic:
        </span><span class="metric-value">0.0% of uOps</span><ul><li><span class="metric-name">FP x87:
        </span><span class="metric-value">0.0% of uOps</span></li></ul><ul><li><span class="metric-name">FP Scalar:
        </span><span class="metric-value">0.0% of uOps</span></li></ul><ul><li><span class="metric-name">FP Vector:
        </span><span class="metric-value">0.0% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">Other:
        </span><span class="metric-value">100.0% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">Heavy Operations:
        </span><span class="metric-value">4.5% of Pipeline Slots</span><ul><li><span class="metric-name">Microcode Sequencer:
        </span><span class="metric-value">3.8% of Pipeline Slots</span><ul><li><span class="metric-name">Assists:
        </span><span class="metric-value">0.0% of Pipeline Slots</span></li></ul></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Front-End Bound:
        </span><span class="metric-value-with-issue">22.0% of Pipeline Slots<div class="issues"><pre class="issue">Issue: A significant portion of Pipeline Slots is remaining empty due to issues in the Front-End.

Tips:  Make sure the code working size is not too large, the code layout does not require too many memory accesses per cycle to get enough instructions for filling four pipeline slots, or check for microcode assists.</pre></div></span><ul><li><span class="metric-name">Front-End Latency:
        </span><span class="metric-value-with-issue">17.6% of Pipeline Slots<div class="issues"><pre class="issue">This metric represents a fraction of slots during which CPU was stalled due to front-end latency issues, such as instruction-cache misses, ITLB misses or fetch stalls after a branch misprediction. In such cases, the front-end delivers no uOps.</pre></div></span><ul><li><span class="metric-name">ICache Misses:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">ITLB Overhead:
        </span><span class="metric-value">1.4% of Clockticks</span></li></ul><ul><li><span class="metric-name">Branch Resteers:
        </span><span class="metric-value">2.1% of Clockticks</span><ul><li><span class="metric-name">Mispredicts Resteers:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Clears Resteers:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Unknown Branches:
        </span><span class="metric-value">2.1% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">DSB Switches:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Length Changing Prefixes:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">MS Switches:
        </span><span class="metric-value-with-issue">0.0% of Clockticks<div class="issues"><pre class="issue">Issue: A significant fraction of cycles was stalled due to switches of uOp delivery to the Microcode Sequencer (MS). Commonly used instructions are optimized for delivery by the DSB or MITE pipelines. Certain operations cannot be handled natively by the execution pipeline, and must be performed by microcode (small programs injected into the execution stream). Switching to the MS too often can negatively impact performance. The MS is designated to deliver long uOp flows required by CISC instructions like CPUID, or uncommon conditions like Floating Point Assists when dealing with Denormals. Note that this metric value may be highlighted due to Microcode Sequencer issue.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Front-End Bandwidth:
        </span><span class="metric-value">4.4% of Pipeline Slots</span><ul><li><span class="metric-name">Front-End Bandwidth MITE:
        </span><span class="metric-value">35.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Front-End Bandwidth DSB:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">(Info) DSB Coverage:
        </span><span class="metric-value">23.8%</span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Bad Speculation:
        </span><span class="metric-value">4.4% of Pipeline Slots</span><ul><li><span class="metric-name">Branch Mispredict:
        </span><span class="metric-value">0.0% of Pipeline Slots</span></li></ul><ul><li><span class="metric-name">Machine Clears:
        </span><span class="metric-value">4.4% of Pipeline Slots</span></li></ul></li></ul><ul><li><span class="metric-name">Back-End Bound:
        </span><span class="metric-value-with-issue">42.8% of Pipeline Slots<div class="issues"><pre class="issue">A significant portion of pipeline slots are remaining empty. When operations take too long in the back-end, they introduce bubbles in the pipeline that ultimately cause fewer pipeline slots containing useful work to be retired per cycle than the machine is capable to support. This opportunity cost results in slower execution. Long-latency operations like divides and memory operations can cause this, as can too many operations being directed to a single execution port (for example, more multiply operations arriving in the back-end per cycle than the execution unit can support).</pre></div></span><ul><li><span class="metric-name">Memory Bound:
        </span><span class="metric-value-with-issue">29.3% of Pipeline Slots<div class="issues"><pre class="issue">The metric value is high. This can indicate that the significant fraction of execution pipeline slots could be stalled due to demand memory load and stores. Use Memory Access analysis to have the metric breakdown by memory hierarchy, memory bandwidth information, correlation by memory objects.</pre></div></span><ul><li><span class="metric-name">L1 Bound:
        </span><span class="metric-value-with-issue">22.8% of Clockticks<div class="issues"><pre class="issue">This metric shows how often machine was stalled without missing the L1 data cache. The L1 cache typically has the shortest latency. However, in certain cases like loads blocked on older stores, a load might suffer a high latency even though it is being satisfied by the L1. Note that this metric value may be highlighted due to DTLB Overhead or Cycles of 1 Port Utilized issues.</pre></div></span><ul><li><span class="metric-name">DTLB Overhead:
        </span><span class="metric-value">1.6% of Clockticks</span><ul><li><span class="metric-name">Load STLB Hit:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Load STLB Miss:
        </span><span class="metric-value">1.6% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Loads Blocked by Store Forwarding:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Lock Latency:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Split Loads:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">4K Aliasing:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">FB Full:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">L2 Bound:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">L3 Bound:
        </span><span class="metric-value">4.6% of Clockticks</span><ul><li><span class="metric-name">Contested Accesses:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Data Sharing:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">L3 Latency:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">SQ Full:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">DRAM Bound:
        </span><span class="metric-value">0.0% of Clockticks</span><ul><li><span class="metric-name">Memory Bandwidth:
        </span><span class="metric-value">4.6% of Clockticks</span></li></ul><ul><li><span class="metric-name">Memory Latency:
        </span><span class="metric-value">18.2% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Store Bound:
        </span><span class="metric-value">0.0% of Clockticks</span><ul><li><span class="metric-name">Store Latency:
        </span><span class="metric-value">9.1% of Clockticks</span></li></ul><ul><li><span class="metric-name">False Sharing:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Split Stores:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">DTLB Store Overhead:
        </span><span class="metric-value">1.5% of Clockticks</span><ul><li><span class="metric-name">Store STLB Hit:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Store STLB Hit:
        </span><span class="metric-value">1.5% of Clockticks</span></li></ul></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Core Bound:
        </span><span class="metric-value-with-issue">13.5% of Pipeline Slots<div class="issues"><pre class="issue">This metric represents how much Core non-memory issues were of a bottleneck. Shortage in hardware compute resources, or dependencies software's instructions are both categorized under Core Bound. Hence it may indicate the machine ran out of an OOO resources, certain execution units are overloaded or dependencies in program's data- or instruction- flow are limiting the performance (e.g. FP-chained long-latency arithmetic operations).</pre></div></span><ul><li><span class="metric-name">Divider:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port Utilization:
        </span><span class="metric-value">10.5% of Clockticks</span><ul><li><span class="metric-name">Cycles of 0 Ports Utilized:
        </span><span class="metric-value">26.4% of Clockticks</span><ul><li><span class="metric-name">Serializing Operations:
        </span><span class="metric-value">18.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Mixing Vectors:
        </span><span class="metric-value">0.0% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">Cycles of 1 Port Utilized:
        </span><span class="metric-value">8.8% of Clockticks</span></li></ul><ul><li><span class="metric-name">Cycles of 2 Ports Utilized:
        </span><span class="metric-value">11.7% of Clockticks</span></li></ul><ul><li><span class="metric-name">Cycles of 3+ Ports Utilized:
        </span><span class="metric-value">20.5% of Clockticks</span><ul><li><span class="metric-name">ALU Operation Utilization:
        </span><span class="metric-value">19.1% of Clockticks</span><ul><li><span class="metric-name">Port 0:
        </span><span class="metric-value">11.7% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 1:
        </span><span class="metric-value">11.7% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 5:
        </span><span class="metric-value">23.4% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 6:
        </span><span class="metric-value">29.3% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Load Operation Utilization:
        </span><span class="metric-value">14.7% of Clockticks</span><ul><li><span class="metric-name">Port 2:
        </span><span class="metric-value">11.7% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 3:
        </span><span class="metric-value">23.4% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Store Operation Utilization:
        </span><span class="metric-value">5.9% of Clockticks</span><ul><li><span class="metric-name">Port 4:
        </span><span class="metric-value">5.9% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 7:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Vector Capacity Usage (FPU):
        </span><span class="metric-value">0.0%</span></li></ul></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Average CPU Frequency:
        </span><span class="metric-value">1.037 GHz </span></li></ul><ul><li><span class="metric-name">Total Thread Count:
        </span><span class="metric-value">9</span></li></ul><ul><li><span class="metric-name">Paused Time:
        </span><span class="metric-value">0s</span></li></ul></li></ul><ul><li><span class="metric-name">Effective Physical Core Utilization:
        </span><span class="metric-value-with-issue">56.8% (2.270 out of 4)<div class="issues"><pre class="issue">The metric value is low, which may signal a poor physical CPU cores utilization caused by:
    - load imbalance
    - threading runtime overhead
    - contended synchronization
    - thread/process underutilization
    - incorrect affinity that utilizes logical cores instead of physical cores
Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism or run the Locks and Waits analysis to identify parallel bottlenecks for other parallel runtimes.</pre></div></span><ul><li><span class="metric-name">Effective Logical Core Utilization:
        </span><span class="metric-value-with-issue">36.5% (2.919 out of 8)<div class="issues"><pre class="issue">The metric value is low, which may signal a poor logical CPU cores utilization. Consider improving physical core utilization as the first step and then look at opportunities to utilize logical cores, which in some cases can improve processor throughput and overall performance of multi-threaded applications.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Collection and Platform Info:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Application Command Line:
        </span><span class="metric-value">./codecs/HHI-VVC/decoder/vvdecapp "-b" "./bin/HHI-VVC/randomaccess_fast.cfg/CLASS_C/RaceHorses_416x240_30_QP_37_HHI-VVC.bin" </span></li></ul><ul><li><span class="metric-name">User Name:
        </span><span class="metric-value">root</span></li></ul><ul><li><span class="metric-name">Operating System:
        </span><span class="metric-value">5.4.0-72-generic DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION="Ubuntu 18.04.5 LTS"</span></li></ul><ul><li><span class="metric-name">Computer Name:
        </span><span class="metric-value">eimon</span></li></ul><ul><li><span class="metric-name">Result Size:
        </span><span class="metric-value">14.4 MB </span></li></ul><ul><li><span class="metric-name">Collection start time:
        </span><span class="metric-value">22:31:20 18/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collection stop time:
        </span><span class="metric-value">22:31:20 18/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collector Type:
        </span><span class="metric-value">Event-based sampling driver</span></li></ul><ul><li><span class="metric-name">CPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Name:
        </span><span class="metric-value">Intel(R) Processor code named Kabylake ULX</span></li></ul><ul><li><span class="metric-name">Frequency:
        </span><span class="metric-value">1.992 GHz </span></li></ul><ul><li><span class="metric-name">Logical CPU Count:
        </span><span class="metric-value">8</span></li></ul><ul><li><span class="metric-name">Cache Allocation Technology:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Level 2 capability:
        </span><span class="metric-value">not detected</span></li></ul><ul><li><span class="metric-name">Level 3 capability:
        </span><span class="metric-value">not detected</span></li></ul></li></ul></li></ul></li></ul></body></html>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<html><style>
        .metric-name {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        }

        .metric-value {
        margin-left: 1em;
        color: #336;
        }

        .metric-value-with-issue {
        margin-left: 1em;
        color: #C33;
        }

        li {
        list-style-type: none;
        }

        ul {
        margin-left: 1.5em;
        padding-left: 0em;
        }

        body {
        margin: 0;
        paddind: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: #336;
        }

        pre {
        white-space:pre-wrap;
        max-width: 40em;
        color: #633;
        }

        .issue {
        border-left: 3px solid #C33;
        padding: 0.3em 0.3em 0.3em 1em;
        }

        table {
        margin: 0 1.5em;
        }

        th, td {
        text-align: left;
        }

        td {
        color: #333;
        }

        th {
        border-bottom: 2px solid #336;
        font-weight: 600;
        }

        .table-value {
        margin-right: 1.5em;
        }

        .brand {
        background-color: #0071c5;
        padding: 0.5em 1.5em;
        width: 100%;
        color: white;
        font-weight: 600;
        }

        .recommendation-placeholder {
        background-color: #eaecee;
        padding: 1em;
        }

        .recommendation-placeholder p {
        font-weight: 600;
        margin: 0;
        }

        .recommendation {
        border-left: 3px solid #bbb;
        padding: 0.3em 0.3em 0.3em 1em;
        margin: 0 0 0 1.5em;
        }

        .recommendation-metric {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        margin: 0 0 0 1.5em;
        }

      </style><body><div class="brand">Intel<sup>&reg;</sup> oneAPI VTune<sup>&trade;</sup> Profiler 2021.1.1 Gold</div><ul><li><span class="metric-name">Elapsed Time:
        </span><span class="metric-value-with-issue">0.043s<div class="issues"><pre class="issue">Application execution time is too short. Metrics data may be unreliable. Consider reducing the sampling interval or increasing your application execution time.</pre></div></span><ul><li><span class="metric-name">Clockticks:
        </span><span class="metric-value">125,460,000</span></li></ul><ul><li><span class="metric-name">Instructions Retired:
        </span><span class="metric-value">100,440,000</span></li></ul><ul><li><span class="metric-name">CPI Rate:
        </span><span class="metric-value-with-issue">1.249<div class="issues"><pre class="issue">The CPI may be too high. This could be caused by issues such as memory stalls, instruction starvation, branch misprediction or long latency instructions. Explore the other hardware-related metrics to identify what is causing high CPI.</pre></div></span></li></ul><ul><li><span class="metric-name">MUX Reliability:
        </span><span class="metric-value">0.830</span></li></ul><ul><li><span class="metric-name">Retiring:
        </span><span class="metric-value-with-issue">48.6% of Pipeline Slots<div class="issues"><pre class="issue">A high fraction of pipeline slots was utilized by useful work. While the goal is to make this metric value as big as possible, a high Retiring value for non-vectorized code could prompt you to consider code vectorization. Vectorization enables doing more computations without significantly increasing the number of instructions, thus improving the performance. Note that this metric value may be highlighted due to Microcode Sequencer (MS) issue, so the performance can be improved by avoiding using the MS.</pre></div></span><ul><li><span class="metric-name">Light Operations:
        </span><span class="metric-value">28.3% of Pipeline Slots</span><ul><li><span class="metric-name">FP Arithmetic:
        </span><span class="metric-value">0.0% of uOps</span><ul><li><span class="metric-name">FP x87:
        </span><span class="metric-value">0.0% of uOps</span></li></ul><ul><li><span class="metric-name">FP Scalar:
        </span><span class="metric-value">0.0% of uOps</span></li></ul><ul><li><span class="metric-name">FP Vector:
        </span><span class="metric-value">0.0% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">Other:
        </span><span class="metric-value">100.0% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">Heavy Operations:
        </span><span class="metric-value-with-issue">20.4% of Pipeline Slots<div class="issues"><pre class="issue">CPU retired heavy-weight operations (instructions that required 2+ uops) in a significant fraction of cycles.</pre></div></span><ul><li><span class="metric-name">Microcode Sequencer:
        </span><span class="metric-value-with-issue">8.1% of Pipeline Slots<div class="issues"><pre class="issue">Issue: A significant fraction of cycles was spent retiring uOps fetched by the Microcode Sequencer.

Tips:

1. Make sure the /arch compiler flags are correct.

2. Check the child Assists metric and, if it is highlighted as an issue, follow the provided recommendations.

Note that this metric value may be highlighted due to MS Switches issue.</pre></div></span><ul><li><span class="metric-name">Assists:
        </span><span class="metric-value">0.0% of Pipeline Slots</span></li></ul></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Front-End Bound:
        </span><span class="metric-value-with-issue">38.0% of Pipeline Slots<div class="issues"><pre class="issue">Issue: A significant portion of Pipeline Slots is remaining empty due to issues in the Front-End.

Tips:  Make sure the code working size is not too large, the code layout does not require too many memory accesses per cycle to get enough instructions for filling four pipeline slots, or check for microcode assists.</pre></div></span><ul><li><span class="metric-name">Front-End Latency:
        </span><span class="metric-value-with-issue">18.2% of Pipeline Slots<div class="issues"><pre class="issue">This metric represents a fraction of slots during which CPU was stalled due to front-end latency issues, such as instruction-cache misses, ITLB misses or fetch stalls after a branch misprediction. In such cases, the front-end delivers no uOps.</pre></div></span><ul><li><span class="metric-name">ICache Misses:
        </span><span class="metric-value-with-issue">8.6% of Clockticks<div class="issues"><pre class="issue">Issue: A significant portion of instruction fetches is missing in the instruction cache.

Tips:

1. Use profile-guided optimization to reduce the size of hot code regions.

2. Consider compiler options to reorder functions so that hot functions are located together.

3. If your application makes significant use of macros, try to reduce this by either converting the relevant macros to functions or using linker options to eliminate repeated code.

4. Consider the Os/O1 optimization level or the following subset of optimizations to decrease your code footprint:
    - use inlining only when it decreases the footprint
    - disable loop unrolling
    - disable intrinsic inlining

Optimization examples:
Instruction Cache Misses recipe from Intel VTune Profiler Performance Analysis Cookbook</pre></div></span></li></ul><ul><li><span class="metric-name">ITLB Overhead:
        </span><span class="metric-value">2.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Branch Resteers:
        </span><span class="metric-value">1.9% of Clockticks</span><ul><li><span class="metric-name">Mispredicts Resteers:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Clears Resteers:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Unknown Branches:
        </span><span class="metric-value">1.9% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">DSB Switches:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Length Changing Prefixes:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">MS Switches:
        </span><span class="metric-value-with-issue">0.0% of Clockticks<div class="issues"><pre class="issue">Issue: A significant fraction of cycles was stalled due to switches of uOp delivery to the Microcode Sequencer (MS). Commonly used instructions are optimized for delivery by the DSB or MITE pipelines. Certain operations cannot be handled natively by the execution pipeline, and must be performed by microcode (small programs injected into the execution stream). Switching to the MS too often can negatively impact performance. The MS is designated to deliver long uOp flows required by CISC instructions like CPUID, or uncommon conditions like Floating Point Assists when dealing with Denormals. Note that this metric value may be highlighted due to Microcode Sequencer issue.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Front-End Bandwidth:
        </span><span class="metric-value-with-issue">19.7% of Pipeline Slots<div class="issues"><pre class="issue">This metric represents a fraction of slots during which CPU was stalled due to front-end bandwidth issues, such as inefficiencies in the instruction decoders or code restrictions for caching in the DSB (decoded uOps cache). In such cases, the front-end typically delivers a non-optimal amount of uOps to the back-end.</pre></div></span><ul><li><span class="metric-name">Front-End Bandwidth MITE:
        </span><span class="metric-value-with-issue">18.2% of Clockticks<div class="issues"><pre class="issue">This metric represents a fraction of cycles during which CPU was stalled due to the MITE fetch pipeline issues, such as inefficiencies in the instruction decoders.</pre></div></span></li></ul><ul><li><span class="metric-name">Front-End Bandwidth DSB:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">(Info) DSB Coverage:
        </span><span class="metric-value-with-issue">22.7%<div class="issues"><pre class="issue">Issue: A significant fraction of uOps was not delivered by the DSB (known as Decoded ICache or uOp Cache). This may happen if a hot code region is too large to fit into the DSB.

Tips: Consider changing the code layout (for example, via profile-guided optimization) to help your hot regions fit into the DSB.

See the "Optimization for Decoded ICache" section in the Intel 64 and IA-32 Architectures Optimization Reference Manual.</pre></div></span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Bad Speculation:
        </span><span class="metric-value">6.1% of Pipeline Slots</span><ul><li><span class="metric-name">Branch Mispredict:
        </span><span class="metric-value">0.0% of Pipeline Slots</span></li></ul><ul><li><span class="metric-name">Machine Clears:
        </span><span class="metric-value">6.1% of Pipeline Slots</span></li></ul></li></ul><ul><li><span class="metric-name">Back-End Bound:
        </span><span class="metric-value">7.3% of Pipeline Slots</span><ul><li><span class="metric-name">Memory Bound:
        </span><span class="metric-value">3.7% of Pipeline Slots</span><ul><li><span class="metric-name">L1 Bound:
        </span><span class="metric-value">30.1% of Clockticks</span><ul><li><span class="metric-name">DTLB Overhead:
        </span><span class="metric-value">0.6% of Clockticks</span><ul><li><span class="metric-name">Load STLB Hit:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Load STLB Miss:
        </span><span class="metric-value">0.6% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Loads Blocked by Store Forwarding:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Lock Latency:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Split Loads:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">4K Aliasing:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">FB Full:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">L2 Bound:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">L3 Bound:
        </span><span class="metric-value">4.3% of Clockticks</span><ul><li><span class="metric-name">Contested Accesses:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Data Sharing:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">L3 Latency:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">SQ Full:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">DRAM Bound:
        </span><span class="metric-value">0.0% of Clockticks</span><ul><li><span class="metric-name">Memory Bandwidth:
        </span><span class="metric-value">4.3% of Clockticks</span></li></ul><ul><li><span class="metric-name">Memory Latency:
        </span><span class="metric-value">21.5% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Store Bound:
        </span><span class="metric-value">0.0% of Clockticks</span><ul><li><span class="metric-name">Store Latency:
        </span><span class="metric-value">21.5% of Clockticks</span></li></ul><ul><li><span class="metric-name">False Sharing:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Split Stores:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">DTLB Store Overhead:
        </span><span class="metric-value">0.9% of Clockticks</span><ul><li><span class="metric-name">Store STLB Hit:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Store STLB Hit:
        </span><span class="metric-value">0.9% of Clockticks</span></li></ul></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Core Bound:
        </span><span class="metric-value">3.7% of Pipeline Slots</span><ul><li><span class="metric-name">Divider:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port Utilization:
        </span><span class="metric-value">29.9% of Clockticks</span><ul><li><span class="metric-name">Cycles of 0 Ports Utilized:
        </span><span class="metric-value">27.3% of Clockticks</span><ul><li><span class="metric-name">Serializing Operations:
        </span><span class="metric-value">17.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Mixing Vectors:
        </span><span class="metric-value">0.0% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">Cycles of 1 Port Utilized:
        </span><span class="metric-value">9.1% of Clockticks</span></li></ul><ul><li><span class="metric-name">Cycles of 2 Ports Utilized:
        </span><span class="metric-value">18.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Cycles of 3+ Ports Utilized:
        </span><span class="metric-value">15.2% of Clockticks</span><ul><li><span class="metric-name">ALU Operation Utilization:
        </span><span class="metric-value">18.2% of Clockticks</span><ul><li><span class="metric-name">Port 0:
        </span><span class="metric-value">12.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 1:
        </span><span class="metric-value">12.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 5:
        </span><span class="metric-value">6.1% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 6:
        </span><span class="metric-value">42.5% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Load Operation Utilization:
        </span><span class="metric-value">6.1% of Clockticks</span><ul><li><span class="metric-name">Port 2:
        </span><span class="metric-value">12.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 3:
        </span><span class="metric-value">12.2% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Store Operation Utilization:
        </span><span class="metric-value">12.2% of Clockticks</span><ul><li><span class="metric-name">Port 4:
        </span><span class="metric-value">12.2% of Clockticks</span></li></ul><ul><li><span class="metric-name">Port 7:
        </span><span class="metric-value">0.0% of Clockticks</span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Vector Capacity Usage (FPU):
        </span><span class="metric-value">0.0%</span></li></ul></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Average CPU Frequency:
        </span><span class="metric-value">972.285 MHz </span></li></ul><ul><li><span class="metric-name">Total Thread Count:
        </span><span class="metric-value">9</span></li></ul><ul><li><span class="metric-name">Paused Time:
        </span><span class="metric-value">0s</span></li></ul></li></ul><ul><li><span class="metric-name">Effective Physical Core Utilization:
        </span><span class="metric-value-with-issue">52.6% (2.104 out of 4)<div class="issues"><pre class="issue">The metric value is low, which may signal a poor physical CPU cores utilization caused by:
    - load imbalance
    - threading runtime overhead
    - contended synchronization
    - thread/process underutilization
    - incorrect affinity that utilizes logical cores instead of physical cores
Explore sub-metrics to estimate the efficiency of MPI and OpenMP parallelism or run the Locks and Waits analysis to identify parallel bottlenecks for other parallel runtimes.</pre></div></span><ul><li><span class="metric-name">Effective Logical Core Utilization:
        </span><span class="metric-value-with-issue">37.1% (2.970 out of 8)<div class="issues"><pre class="issue">The metric value is low, which may signal a poor logical CPU cores utilization. Consider improving physical core utilization as the first step and then look at opportunities to utilize logical cores, which in some cases can improve processor throughput and overall performance of multi-threaded applications.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Collection and Platform Info:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Application Command Line:
        </span><span class="metric-value">./codecs/HHI-VVC/decoder/vvdecapp "-b" "./bin/HHI-VVC/randomaccess_fast.cfg/CLASS_C/RaceHorses_416x240_30_QP_37_HHI-VVC.bin" </span></li></ul><ul><li><span class="metric-name">User Name:
        </span><span class="metric-value">root</span></li></ul><ul><li><span class="metric-name">Operating System:
        </span><span class="metric-value">5.4.0-72-generic DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION="Ubuntu 18.04.5 LTS"</span></li></ul><ul><li><span class="metric-name">Computer Name:
        </span><span class="metric-value">eimon</span></li></ul><ul><li><span class="metric-name">Result Size:
        </span><span class="metric-value">14.3 MB </span></li></ul><ul><li><span class="metric-name">Collection start time:
        </span><span class="metric-value">07:51:41 19/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collection stop time:
        </span><span class="metric-value">07:51:41 19/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collector Type:
        </span><span class="metric-value">Event-based sampling driver</span></li></ul><ul><li><span class="metric-name">CPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Name:
        </span><span class="metric-value">Intel(R) Processor code named Kabylake ULX</span></li></ul><ul><li><span class="metric-name">Frequency:
        </span><span class="metric-value">1.992 GHz </span></li></ul><ul><li><span class="metric-name">Logical CPU Count:
        </span><span class="metric-value">8</span></li></ul><ul><li><span class="metric-name">Cache Allocation Technology:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Level 2 capability:
        </span><span class="metric-value">not detected</span></li></ul><ul><li><span class="metric-name">Level 3 capability:
        </span><span class="metric-value">not detected</span></li></ul></li></ul></li></ul></li></ul></body></html>

