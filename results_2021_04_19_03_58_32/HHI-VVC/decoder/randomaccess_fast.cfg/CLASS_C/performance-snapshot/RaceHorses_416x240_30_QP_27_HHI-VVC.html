<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<html><style>
        .metric-name {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        }

        .metric-value {
        margin-left: 1em;
        color: #336;
        }

        .metric-value-with-issue {
        margin-left: 1em;
        color: #C33;
        }

        li {
        list-style-type: none;
        }

        ul {
        margin-left: 1.5em;
        padding-left: 0em;
        }

        body {
        margin: 0;
        paddind: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: #336;
        }

        pre {
        white-space:pre-wrap;
        max-width: 40em;
        color: #633;
        }

        .issue {
        border-left: 3px solid #C33;
        padding: 0.3em 0.3em 0.3em 1em;
        }

        table {
        margin: 0 1.5em;
        }

        th, td {
        text-align: left;
        }

        td {
        color: #333;
        }

        th {
        border-bottom: 2px solid #336;
        font-weight: 600;
        }

        .table-value {
        margin-right: 1.5em;
        }

        .brand {
        background-color: #0071c5;
        padding: 0.5em 1.5em;
        width: 100%;
        color: white;
        font-weight: 600;
        }

        .recommendation-placeholder {
        background-color: #eaecee;
        padding: 1em;
        }

        .recommendation-placeholder p {
        font-weight: 600;
        margin: 0;
        }

        .recommendation {
        border-left: 3px solid #bbb;
        padding: 0.3em 0.3em 0.3em 1em;
        margin: 0 0 0 1.5em;
        }

        .recommendation-metric {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        margin: 0 0 0 1.5em;
        }

      </style><body><div class="brand">Intel<sup>&reg;</sup> oneAPI VTune<sup>&trade;</sup> Profiler 2021.1.1 Gold</div><div class="recommendation-placeholder"><p>Recommendations:</p><span class="recommendation-metric">Increase execution time:  </span><pre class="recommendation">Application execution time is too short. Metrics data may be unreliable. Consider reducing the sampling interval or increasing your application execution time.</pre><span class="recommendation-metric">Hotspots: Start with Hotspots analysis to understand the efficiency of your algorithm.</span><pre class="recommendation">Use Hotspots analysis to identify the most time consuming functions. Drill down to see the time spent on every line of code.</pre><span class="recommendation-metric">Microarchitecture Exploration: There is low microarchitecture usage (15.0%) of available hardware resources.  of Pipeline Slots</span><pre class="recommendation">Run Microarchitecture Exploration analysis to analyze CPU microarchitecture bottlenecks that can affect application performance.</pre><span class="recommendation-metric">Memory Access: The Memory Bound metric is high  (26.1%). A significant fraction of execution pipeline slots could be stalled due to demand memory load and stores.  of Pipeline Slots</span><pre class="recommendation">Use Memory Access analysis to measure metrics that can identify memory access issues.</pre><span class="recommendation-metric">Threading: There is poor utilization of logical CPU cores (69.3%) in your application. </span><pre class="recommendation"> Use Threading to explore more opportunities to increase parallelism in your application.</pre></div><ul><li><span class="metric-name">Elapsed Time:
        </span><span class="metric-value-with-issue">0.048s<div class="issues"><pre class="issue">Application execution time is too short. Metrics data may be unreliable. Consider reducing the sampling interval or increasing your application execution time.</pre></div></span><ul><li><span class="metric-name">CPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">IPC:
        </span><span class="metric-value-with-issue">0.768<div class="issues"><pre class="issue">The IPC may be too low. This could be caused by issues such as memory stalls, instruction starvation, branch misprediction or long latency instructions. Explore the other hardware-related metrics to identify what is causing low IPC.</pre></div></span></li></ul><ul><li><span class="metric-name">SP GFLOPS:
        </span><span class="metric-value">0.002</span></li></ul><ul><li><span class="metric-name">DP GFLOPS:
        </span><span class="metric-value">0.000</span></li></ul><ul><li><span class="metric-name">x87 GFLOPS:
        </span><span class="metric-value">0.001</span></li></ul><ul><li><span class="metric-name">Average CPU Frequency:
        </span><span class="metric-value">971.516 MHz </span></li></ul></li></ul><ul><li><span class="metric-name">GPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Time:
        </span><span class="metric-value-with-issue">37.5% (0.018s) of Elapsed time<div class="issues"><pre class="issue">GPU utilization is low. Consider offloading more work to the GPU to increase overall application performance.</pre></div></span></li></ul><ul><li><span class="metric-name">IPC Rate:
        </span><span class="metric-value">1.286</span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Effective Logical Core Utilization:
        </span><span class="metric-value-with-issue">69.3% (5.541 out of 8)<div class="issues"><pre class="issue">The metric value is low, which may signal a poor utilization of logical CPU cores while the utilization of physical cores is acceptable. Consider using logical cores, which in some cases can improve processor throughput and overall performance of multi-threaded applications.</pre></div></span><ul><li><span class="metric-name">Effective Physical Core Utilization:
        </span><span class="metric-value">100.0% (4.000 out of 4)</span></li></ul></li></ul><ul><li><span class="metric-name">Microarchitecture Usage:
        </span><span class="metric-value-with-issue">15.0% of Pipeline Slots<div class="issues"><pre class="issue">You code efficiency on this platform is too low.

Possible cause: memory stalls, instruction starvation, branch misprediction or long latency instructions.

Next steps: Run Microarchitecture Exploration analysis to identify the cause of the low microarchitecture usage efficiency.</pre></div></span><ul><li><span class="metric-name">Retiring:
        </span><span class="metric-value">15.0% of Pipeline Slots</span></li></ul><ul><li><span class="metric-name">Front-End Bound:
        </span><span class="metric-value-with-issue">24.3% of Pipeline Slots<div class="issues"><pre class="issue">Issue: A significant portion of Pipeline Slots is remaining empty due to issues in the Front-End.

Tips:  Make sure the code working size is not too large, the code layout does not require too many memory accesses per cycle to get enough instructions for filling four pipeline slots, or check for microcode assists.</pre></div></span></li></ul><ul><li><span class="metric-name">Back-End Bound:
        </span><span class="metric-value-with-issue">54.9% of Pipeline Slots<div class="issues"><pre class="issue">A significant portion of pipeline slots are remaining empty. When operations take too long in the back-end, they introduce bubbles in the pipeline that ultimately cause fewer pipeline slots containing useful work to be retired per cycle than the machine is capable to support. This opportunity cost results in slower execution. Long-latency operations like divides and memory operations can cause this, as can too many operations being directed to a single execution port (for example, more multiply operations arriving in the back-end per cycle than the execution unit can support).</pre></div></span><ul><li><span class="metric-name">Memory Bound:
        </span><span class="metric-value-with-issue">26.1% of Pipeline Slots<div class="issues"><pre class="issue">The metric value is high. This can indicate that the significant fraction of execution pipeline slots could be stalled due to demand memory load and stores. Use Memory Access analysis to have the metric breakdown by memory hierarchy, memory bandwidth information, correlation by memory objects.</pre></div></span></li></ul><ul><li><span class="metric-name">Core Bound:
        </span><span class="metric-value-with-issue">28.8% of Pipeline Slots<div class="issues"><pre class="issue">This metric represents how much Core non-memory issues were of a bottleneck. Shortage in hardware compute resources, or dependencies software's instructions are both categorized under Core Bound. Hence it may indicate the machine ran out of an OOO resources, certain execution units are overloaded or dependencies in program's data- or instruction- flow are limiting the performance (e.g. FP-chained long-latency arithmetic operations).</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Bad Speculation:
        </span><span class="metric-value">5.8% of Pipeline Slots</span></li></ul></li></ul><ul><li><span class="metric-name">Memory Bound:
        </span><span class="metric-value-with-issue">26.1% of Pipeline Slots<div class="issues"><pre class="issue">The metric value is high. This can indicate that the significant fraction of execution pipeline slots could be stalled due to demand memory load and stores. Use Memory Access analysis to have the metric breakdown by memory hierarchy, memory bandwidth information, correlation by memory objects.</pre></div></span><ul><li><span class="metric-name">L1 Bound:
        </span><span class="metric-value-with-issue">28.4% of Clockticks<div class="issues"><pre class="issue">This metric shows how often machine was stalled without missing the L1 data cache. The L1 cache typically has the shortest latency. However, in certain cases like loads blocked on older stores, a load might suffer a high latency even though it is being satisfied by the L1.</pre></div></span></li></ul><ul><li><span class="metric-name">L2 Bound:
        </span><span class="metric-value">0.3% of Clockticks</span></li></ul><ul><li><span class="metric-name">L3 Bound:
        </span><span class="metric-value">2.5% of Clockticks</span></li></ul><ul><li><span class="metric-name">DRAM Bound:
        </span><span class="metric-value">5.6% of Clockticks</span><ul><li><span class="metric-name">DRAM Bandwidth Bound:
        </span><span class="metric-value">0.0% of Elapsed Time</span></li></ul></li></ul><ul><li><span class="metric-name">Store Bound:
        </span><span class="metric-value">0.7% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Vectorization:
        </span><span class="metric-value-with-issue">0.0% of Packed FP Operations<div class="issues"><pre class="issue">A significant fraction of floating point arithmetic instructions are scalar. Use Intel Advisor to see possible reasons why the code was not vectorized.</pre></div></span><ul><li><span class="metric-name">Instruction Mix:
        </span><span class="metric-value"/><ul><li><span class="metric-name">SP FLOPs:
        </span><span class="metric-value">0.1% of uOps</span><ul><li><span class="metric-name">Packed:
        </span><span class="metric-value">0.0% from SP FP</span><ul><li><span class="metric-name">128-bit:
        </span><span class="metric-value">0.0% from SP FP</span></li></ul><ul><li><span class="metric-name">256-bit:
        </span><span class="metric-value">0.0% from SP FP</span></li></ul></li></ul><ul><li><span class="metric-name">Scalar:
        </span><span class="metric-value-with-issue">100.0% from SP FP<div class="issues"><pre class="issue">This code has floating point operations and is not vectorized. Consider using Intel Advisor to vectorize the loops.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">DP FLOPs:
        </span><span class="metric-value">0.0% of uOps</span><ul><li><span class="metric-name">Packed:
        </span><span class="metric-value">4.2% from DP FP</span><ul><li><span class="metric-name">128-bit:
        </span><span class="metric-value">4.2% from DP FP</span></li></ul><ul><li><span class="metric-name">256-bit:
        </span><span class="metric-value">0.0% from DP FP</span></li></ul></li></ul><ul><li><span class="metric-name">Scalar:
        </span><span class="metric-value-with-issue">95.8% from DP FP<div class="issues"><pre class="issue">A significant fraction of floating point arithmetic instructions are scalar. Use Intel Advisor to see possible reasons why the code was not vectorized.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">x87 FLOPs:
        </span><span class="metric-value">0.0% of uOps</span></li></ul><ul><li><span class="metric-name">Non-FP:
        </span><span class="metric-value">99.9% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">FP Arith/Mem Rd Instr. Ratio:
        </span><span class="metric-value-with-issue">0.002<div class="issues"><pre class="issue">The metric value is low. This can be a result of unaligned access to data for vector operations. Use Intel Advisor to find possible data access inefficiencies for vector operations.</pre></div></span></li></ul><ul><li><span class="metric-name">FP Arith/Mem Wr Instr. Ratio:
        </span><span class="metric-value-with-issue">0.005<div class="issues"><pre class="issue">The metric value is low. This can be a result of unaligned access to data for vector operations. Use Intel Advisor to find possible data access inefficiencies for vector operations.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">GPU Active Time:
        </span><span class="metric-value-with-issue">37.5%<div class="issues"><pre class="issue">GPU utilization is low. Consider offloading more work to the GPU to increase overall application performance.</pre></div></span><ul><li><span class="metric-name">GPU Utilization when Busy:
        </span><span class="metric-value-with-issue">17.8%<div class="issues"><pre class="issue">The percentage of time when the EUs were stalled or idle is high, which has a negative impact on compute-bound applications.</pre></div></span></li></ul><ul><li><span class="metric-name">IPC Rate:
        </span><span class="metric-value">1.286</span></li></ul><ul><li><span class="metric-name">EU State:
        </span><span class="metric-value">17.8%</span><ul><li><span class="metric-name">Active:
        </span><span class="metric-value">17.8%</span></li></ul><ul><li><span class="metric-name">Stalled:
        </span><span class="metric-value-with-issue">33.8%<div class="issues"><pre class="issue">A significant portion of GPU time is lost due to stalls. For compute-bound code, this could indicate that performance is limited by memory or sampler acesses.</pre></div></span></li></ul><ul><li><span class="metric-name">Idle:
        </span><span class="metric-value-with-issue">48.4%<div class="issues"><pre class="issue">A significant portion of GPU time is spent idle. This is usually caused by imbalance or thread scheduling problems.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Occupancy:
        </span><span class="metric-value-with-issue">31.4% of peak value<div class="issues"><pre class="issue">Low value of the occupancy metric may be caused by inefficient work scheduling. Make sure work items are neither too small nor too large.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Collection and Platform Info:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Application Command Line:
        </span><span class="metric-value">./codecs/HHI-VVC/decoder/vvdecapp "-b" "./bin/HHI-VVC/randomaccess_fast.cfg/CLASS_C/RaceHorses_416x240_30_QP_27_HHI-VVC.bin" </span></li></ul><ul><li><span class="metric-name">Operating System:
        </span><span class="metric-value">5.4.0-72-generic DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION="Ubuntu 18.04.5 LTS"</span></li></ul><ul><li><span class="metric-name">Computer Name:
        </span><span class="metric-value">eimon</span></li></ul><ul><li><span class="metric-name">Result Size:
        </span><span class="metric-value">3.7 MB </span></li></ul><ul><li><span class="metric-name">Collection start time:
        </span><span class="metric-value">22:29:28 18/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collection stop time:
        </span><span class="metric-value">22:29:28 18/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collector Type:
        </span><span class="metric-value">Event-based sampling driver,Event-based counting driver</span></li></ul><ul><li><span class="metric-name">CPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Name:
        </span><span class="metric-value">Intel(R) Processor code named Kabylake ULX</span></li></ul><ul><li><span class="metric-name">Frequency:
        </span><span class="metric-value">1.992 GHz </span></li></ul><ul><li><span class="metric-name">Logical CPU Count:
        </span><span class="metric-value">8</span></li></ul><ul><li><span class="metric-name">Max DRAM Single-Package Bandwidth:
        </span><span class="metric-value">11.000 GB/s</span></li></ul><ul><li><span class="metric-name">Cache Allocation Technology:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Level 2 capability:
        </span><span class="metric-value">not detected</span></li></ul><ul><li><span class="metric-name">Level 3 capability:
        </span><span class="metric-value">not detected</span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">GPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Name:
        </span><span class="metric-value">Display controller: Intel Corporation Device 22807</span></li></ul><ul><li><span class="metric-name">Vendor:
        </span><span class="metric-value">Intel Corporation</span></li></ul><ul><li><span class="metric-name">EU Count:
        </span><span class="metric-value">24</span></li></ul><ul><li><span class="metric-name">Max EU Thread Count:
        </span><span class="metric-value">7</span></li></ul><ul><li><span class="metric-name">Max Core Frequency:
        </span><span class="metric-value">1.150 GHz </span></li></ul></li></ul></li></ul></body></html>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<html><style>
        .metric-name {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        }

        .metric-value {
        margin-left: 1em;
        color: #336;
        }

        .metric-value-with-issue {
        margin-left: 1em;
        color: #C33;
        }

        li {
        list-style-type: none;
        }

        ul {
        margin-left: 1.5em;
        padding-left: 0em;
        }

        body {
        margin: 0;
        paddind: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: #336;
        }

        pre {
        white-space:pre-wrap;
        max-width: 40em;
        color: #633;
        }

        .issue {
        border-left: 3px solid #C33;
        padding: 0.3em 0.3em 0.3em 1em;
        }

        table {
        margin: 0 1.5em;
        }

        th, td {
        text-align: left;
        }

        td {
        color: #333;
        }

        th {
        border-bottom: 2px solid #336;
        font-weight: 600;
        }

        .table-value {
        margin-right: 1.5em;
        }

        .brand {
        background-color: #0071c5;
        padding: 0.5em 1.5em;
        width: 100%;
        color: white;
        font-weight: 600;
        }

        .recommendation-placeholder {
        background-color: #eaecee;
        padding: 1em;
        }

        .recommendation-placeholder p {
        font-weight: 600;
        margin: 0;
        }

        .recommendation {
        border-left: 3px solid #bbb;
        padding: 0.3em 0.3em 0.3em 1em;
        margin: 0 0 0 1.5em;
        }

        .recommendation-metric {
        font-weight: 600;
        min-width: 14em;
        display: inline-block;
        margin: 0 0 0 1.5em;
        }

      </style><body><div class="brand">Intel<sup>&reg;</sup> oneAPI VTune<sup>&trade;</sup> Profiler 2021.1.1 Gold</div><div class="recommendation-placeholder"><p>Recommendations:</p><span class="recommendation-metric">Increase execution time:  </span><pre class="recommendation">Application execution time is too short. Metrics data may be unreliable. Consider reducing the sampling interval or increasing your application execution time.</pre><span class="recommendation-metric">Hotspots: Start with Hotspots analysis to understand the efficiency of your algorithm.</span><pre class="recommendation">Use Hotspots analysis to identify the most time consuming functions. Drill down to see the time spent on every line of code.</pre><span class="recommendation-metric">Microarchitecture Exploration: There is low microarchitecture usage (1.7%) of available hardware resources.  of Pipeline Slots</span><pre class="recommendation">Run Microarchitecture Exploration analysis to analyze CPU microarchitecture bottlenecks that can affect application performance.</pre><span class="recommendation-metric">Memory Access: The Memory Bound metric is high  (48.9%). A significant fraction of execution pipeline slots could be stalled due to demand memory load and stores.  of Pipeline Slots</span><pre class="recommendation">Use Memory Access analysis to measure metrics that can identify memory access issues.</pre></div><ul><li><span class="metric-name">Elapsed Time:
        </span><span class="metric-value-with-issue">0.028s<div class="issues"><pre class="issue">Application execution time is too short. Metrics data may be unreliable. Consider reducing the sampling interval or increasing your application execution time.</pre></div></span><ul><li><span class="metric-name">CPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">IPC:
        </span><span class="metric-value-with-issue">0.056<div class="issues"><pre class="issue">The IPC may be too low. This could be caused by issues such as memory stalls, instruction starvation, branch misprediction or long latency instructions. Explore the other hardware-related metrics to identify what is causing low IPC.</pre></div></span></li></ul><ul><li><span class="metric-name">DP GFLOPS:
        </span><span class="metric-value">0.000</span></li></ul><ul><li><span class="metric-name">x87 GFLOPS:
        </span><span class="metric-value">0.001</span></li></ul><ul><li><span class="metric-name">Average CPU Frequency:
        </span><span class="metric-value">1.988 GHz </span></li></ul></li></ul><ul><li><span class="metric-name">GPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Time:
        </span><span class="metric-value-with-issue">31.2% (0.009s) of Elapsed time<div class="issues"><pre class="issue">GPU utilization is low. Consider offloading more work to the GPU to increase overall application performance.</pre></div></span></li></ul><ul><li><span class="metric-name">IPC Rate:
        </span><span class="metric-value">1.319</span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">Effective Logical Core Utilization:
        </span><span class="metric-value">132.9% (10.634 out of 8)</span><ul><li><span class="metric-name">Effective Physical Core Utilization:
        </span><span class="metric-value">100.0% (4.000 out of 4)</span></li></ul></li></ul><ul><li><span class="metric-name">Microarchitecture Usage:
        </span><span class="metric-value-with-issue">1.7% of Pipeline Slots<div class="issues"><pre class="issue">You code efficiency on this platform is too low.

Possible cause: memory stalls, instruction starvation, branch misprediction or long latency instructions.

Next steps: Run Microarchitecture Exploration analysis to identify the cause of the low microarchitecture usage efficiency.</pre></div></span><ul><li><span class="metric-name">Retiring:
        </span><span class="metric-value">1.7% of Pipeline Slots</span></li></ul><ul><li><span class="metric-name">Front-End Bound:
        </span><span class="metric-value">8.9% of Pipeline Slots</span></li></ul><ul><li><span class="metric-name">Back-End Bound:
        </span><span class="metric-value-with-issue">88.1% of Pipeline Slots<div class="issues"><pre class="issue">A significant portion of pipeline slots are remaining empty. When operations take too long in the back-end, they introduce bubbles in the pipeline that ultimately cause fewer pipeline slots containing useful work to be retired per cycle than the machine is capable to support. This opportunity cost results in slower execution. Long-latency operations like divides and memory operations can cause this, as can too many operations being directed to a single execution port (for example, more multiply operations arriving in the back-end per cycle than the execution unit can support).</pre></div></span><ul><li><span class="metric-name">Memory Bound:
        </span><span class="metric-value-with-issue">48.9% of Pipeline Slots<div class="issues"><pre class="issue">The metric value is high. This can indicate that the significant fraction of execution pipeline slots could be stalled due to demand memory load and stores. Use Memory Access analysis to have the metric breakdown by memory hierarchy, memory bandwidth information, correlation by memory objects.</pre></div></span></li></ul><ul><li><span class="metric-name">Core Bound:
        </span><span class="metric-value-with-issue">39.2% of Pipeline Slots<div class="issues"><pre class="issue">This metric represents how much Core non-memory issues were of a bottleneck. Shortage in hardware compute resources, or dependencies software's instructions are both categorized under Core Bound. Hence it may indicate the machine ran out of an OOO resources, certain execution units are overloaded or dependencies in program's data- or instruction- flow are limiting the performance (e.g. FP-chained long-latency arithmetic operations).</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Bad Speculation:
        </span><span class="metric-value">1.3% of Pipeline Slots</span></li></ul></li></ul><ul><li><span class="metric-name">Memory Bound:
        </span><span class="metric-value-with-issue">48.9% of Pipeline Slots<div class="issues"><pre class="issue">The metric value is high. This can indicate that the significant fraction of execution pipeline slots could be stalled due to demand memory load and stores. Use Memory Access analysis to have the metric breakdown by memory hierarchy, memory bandwidth information, correlation by memory objects.</pre></div></span><ul><li><span class="metric-name">L1 Bound:
        </span><span class="metric-value-with-issue">36.1% of Clockticks<div class="issues"><pre class="issue">This metric shows how often machine was stalled without missing the L1 data cache. The L1 cache typically has the shortest latency. However, in certain cases like loads blocked on older stores, a load might suffer a high latency even though it is being satisfied by the L1.</pre></div></span></li></ul><ul><li><span class="metric-name">L2 Bound:
        </span><span class="metric-value">0.4% of Clockticks</span></li></ul><ul><li><span class="metric-name">L3 Bound:
        </span><span class="metric-value">2.6% of Clockticks</span></li></ul><ul><li><span class="metric-name">DRAM Bound:
        </span><span class="metric-value">5.9% of Clockticks</span><ul><li><span class="metric-name">DRAM Bandwidth Bound:
        </span><span class="metric-value-with-issue">70.5% of Elapsed Time<div class="issues"><pre class="issue">The system spent much time heavily utilizing DRAM bandwidth. Improve data accesses to reduce cacheline transfers from/to memory using these possible techniques: 1) consume all bytes of each cacheline before it is evicted (for example, reorder structure elements and split non-hot ones); 2) merge compute-limited and bandwidth-limited loops; 3) use NUMA optimizations on a multi-socket system. Note: software prefetches do not help a bandwidth-limited application. Run Memory Access analysis to identify data structures to be allocated in High Bandwidth Memory (HBM), if available.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Store Bound:
        </span><span class="metric-value">0.2% of Clockticks</span></li></ul></li></ul><ul><li><span class="metric-name">Vectorization:
        </span><span class="metric-value-with-issue">0.0% of Packed FP Operations<div class="issues"><pre class="issue">A significant fraction of floating point arithmetic instructions are scalar. Use Intel Advisor to see possible reasons why the code was not vectorized.</pre></div></span><ul><li><span class="metric-name">Instruction Mix:
        </span><span class="metric-value"/><ul><li><span class="metric-name">SP FLOPs:
        </span><span class="metric-value">0.0% of uOps</span><ul><li><span class="metric-name">Packed:
        </span><span class="metric-value">0.0% from SP FP</span><ul><li><span class="metric-name">128-bit:
        </span><span class="metric-value">0.0% from SP FP</span></li></ul><ul><li><span class="metric-name">256-bit:
        </span><span class="metric-value">0.0% from SP FP</span></li></ul></li></ul><ul><li><span class="metric-name">Scalar:
        </span><span class="metric-value">0.0% from SP FP</span></li></ul></li></ul><ul><li><span class="metric-name">DP FLOPs:
        </span><span class="metric-value">0.0% of uOps</span><ul><li><span class="metric-name">Packed:
        </span><span class="metric-value">0.0% from DP FP</span><ul><li><span class="metric-name">128-bit:
        </span><span class="metric-value">0.0% from DP FP</span></li></ul><ul><li><span class="metric-name">256-bit:
        </span><span class="metric-value">0.0% from DP FP</span></li></ul></li></ul><ul><li><span class="metric-name">Scalar:
        </span><span class="metric-value-with-issue">100.0% from DP FP<div class="issues"><pre class="issue">This code has floating point operations and is not vectorized. Consider using Intel Advisor to vectorize the loops.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">x87 FLOPs:
        </span><span class="metric-value">0.1% of uOps</span></li></ul><ul><li><span class="metric-name">Non-FP:
        </span><span class="metric-value">99.9% of uOps</span></li></ul></li></ul><ul><li><span class="metric-name">FP Arith/Mem Rd Instr. Ratio:
        </span><span class="metric-value-with-issue">0.004<div class="issues"><pre class="issue">The metric value is low. This can be a result of unaligned access to data for vector operations. Use Intel Advisor to find possible data access inefficiencies for vector operations.</pre></div></span></li></ul><ul><li><span class="metric-name">FP Arith/Mem Wr Instr. Ratio:
        </span><span class="metric-value-with-issue">0.006<div class="issues"><pre class="issue">The metric value is low. This can be a result of unaligned access to data for vector operations. Use Intel Advisor to find possible data access inefficiencies for vector operations.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">GPU Active Time:
        </span><span class="metric-value-with-issue">31.2%<div class="issues"><pre class="issue">GPU utilization is low. Consider offloading more work to the GPU to increase overall application performance.</pre></div></span><ul><li><span class="metric-name">GPU Utilization when Busy:
        </span><span class="metric-value-with-issue">22.4%<div class="issues"><pre class="issue">The percentage of time when the EUs were stalled or idle is high, which has a negative impact on compute-bound applications.</pre></div></span></li></ul><ul><li><span class="metric-name">IPC Rate:
        </span><span class="metric-value">1.319</span></li></ul><ul><li><span class="metric-name">EU State:
        </span><span class="metric-value">22.4%</span><ul><li><span class="metric-name">Active:
        </span><span class="metric-value">22.4%</span></li></ul><ul><li><span class="metric-name">Stalled:
        </span><span class="metric-value-with-issue">35.3%<div class="issues"><pre class="issue">A significant portion of GPU time is lost due to stalls. For compute-bound code, this could indicate that performance is limited by memory or sampler acesses.</pre></div></span></li></ul><ul><li><span class="metric-name">Idle:
        </span><span class="metric-value-with-issue">42.2%<div class="issues"><pre class="issue">A significant portion of GPU time is spent idle. This is usually caused by imbalance or thread scheduling problems.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Occupancy:
        </span><span class="metric-value-with-issue">36.5% of peak value<div class="issues"><pre class="issue">Low value of the occupancy metric may be caused by inefficient work scheduling. Make sure work items are neither too small nor too large.</pre></div></span></li></ul></li></ul><ul><li><span class="metric-name">Collection and Platform Info:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Application Command Line:
        </span><span class="metric-value">./codecs/HHI-VVC/decoder/vvdecapp "-b" "./bin/HHI-VVC/randomaccess_fast.cfg/CLASS_C/RaceHorses_416x240_30_QP_27_HHI-VVC.bin" </span></li></ul><ul><li><span class="metric-name">Operating System:
        </span><span class="metric-value">5.4.0-72-generic DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION="Ubuntu 18.04.5 LTS"</span></li></ul><ul><li><span class="metric-name">Computer Name:
        </span><span class="metric-value">eimon</span></li></ul><ul><li><span class="metric-name">Result Size:
        </span><span class="metric-value">3.7 MB </span></li></ul><ul><li><span class="metric-name">Collection start time:
        </span><span class="metric-value">07:49:15 19/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collection stop time:
        </span><span class="metric-value">07:49:15 19/04/2021 UTC</span></li></ul><ul><li><span class="metric-name">Collector Type:
        </span><span class="metric-value">Event-based sampling driver,Event-based counting driver</span></li></ul><ul><li><span class="metric-name">CPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Name:
        </span><span class="metric-value">Intel(R) Processor code named Kabylake ULX</span></li></ul><ul><li><span class="metric-name">Frequency:
        </span><span class="metric-value">1.992 GHz </span></li></ul><ul><li><span class="metric-name">Logical CPU Count:
        </span><span class="metric-value">8</span></li></ul><ul><li><span class="metric-name">Max DRAM Single-Package Bandwidth:
        </span><span class="metric-value">10.000 GB/s</span></li></ul><ul><li><span class="metric-name">Cache Allocation Technology:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Level 2 capability:
        </span><span class="metric-value">not detected</span></li></ul><ul><li><span class="metric-name">Level 3 capability:
        </span><span class="metric-value">not detected</span></li></ul></li></ul></li></ul><ul><li><span class="metric-name">GPU:
        </span><span class="metric-value"/><ul><li><span class="metric-name">Name:
        </span><span class="metric-value">Display controller: Intel Corporation Device 22807</span></li></ul><ul><li><span class="metric-name">Vendor:
        </span><span class="metric-value">Intel Corporation</span></li></ul><ul><li><span class="metric-name">EU Count:
        </span><span class="metric-value">24</span></li></ul><ul><li><span class="metric-name">Max EU Thread Count:
        </span><span class="metric-value">7</span></li></ul><ul><li><span class="metric-name">Max Core Frequency:
        </span><span class="metric-value">1.150 GHz </span></li></ul></li></ul></li></ul></body></html>

